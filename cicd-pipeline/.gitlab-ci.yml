stages:
  - test
  - build
  - deploy

variables:
  DOCKER_IMAGE: $CI_REGISTRY_IMAGE:$CI_COMMIT_SHA
  DOCKER_IMAGE_LATEST: $CI_REGISTRY_IMAGE:latest
  STAGING_SERVER: "staging.company.com"
  PRODUCTION_SERVER: "api.company.com"

# Estágio de Testes
unit_tests:
  stage: test
  image: node:18-alpine
  services:
    - redis:7-alpine
    - postgres:15-alpine
  variables:
    POSTGRES_DB: test_db
    POSTGRES_USER: test_user
    POSTGRES_PASSWORD: test_pass
    REDIS_URL: redis://redis:6379
  before_script:
    - npm ci --only=dev
  script:
    - npm run test:unit
    - npm run test:integration
    - npm run lint
    - npm run security-audit
  coverage: '/Statements.*?(\d+(?:\.\d+)?)%/'
  artifacts:
    reports:
      coverage_report:
        coverage_format: cobertura
        path: coverage/cobertura-coverage.xml
      junit: test-results.xml
    paths:
      - coverage/
    expire_in: 30 days
  only:
    - merge_requests
    - main
    - develop

# Análise de Segurança
security_scan:
  stage: test
  image: owasp/zap2docker-stable
  script:
    - mkdir -p /zap/wrk/
    - /zap/zap-baseline.py -t http://app:3000 -J zap-report.json
  artifacts:
    reports:
      sast: zap-report.json
    expire_in: 1 week
  allow_failure: true
  only:
    - merge_requests
    - main

# Build da Imagem Docker
build_image:
  stage: build
  image: docker:24-dind
  services:
    - docker:24-dind
  variables:
    DOCKER_TLS_CERTDIR: "/certs"
  before_script:
    - echo $CI_REGISTRY_PASSWORD | docker login -u $CI_REGISTRY_USER --password-stdin $CI_REGISTRY
  script:
    - docker build --pull -t $DOCKER_IMAGE .
    - docker tag $DOCKER_IMAGE $DOCKER_IMAGE_LATEST
    - docker push $DOCKER_IMAGE
    - docker push $DOCKER_IMAGE_LATEST
    # Escanear vulnerabilidades na imagem
    - docker run --rm -v /var/run/docker.sock:/var/run/docker.sock 
      -v $(pwd):/tmp aquasec/trivy image --format json --output /tmp/trivy-report.json $DOCKER_IMAGE
  artifacts:
    paths:
      - trivy-report.json
    expire_in: 1 week
  dependencies:
    - unit_tests
  only:
    - main
    - develop

# Deploy Staging
deploy_staging:
  stage: deploy
  image: alpine:latest
  environment:
    name: staging
    url: https://staging.company.com
  before_script:
    - apk add --no-cache openssh-client
    - eval $(ssh-agent -s)
    - echo "$SSH_PRIVATE_KEY" | tr -d '\r' | ssh-add -
    - mkdir -p ~/.ssh
    - chmod 700 ~/.ssh
    - ssh-keyscan $STAGING_SERVER >> ~/.ssh/known_hosts
  script:
    - |
      ssh deploy@$STAGING_SERVER "
        docker pull $DOCKER_IMAGE &&
        docker stop api-staging || true &&
        docker rm api-staging || true &&
        docker run -d --name api-staging \
          --restart unless-stopped \
          -p 3000:3000 \
          -e NODE_ENV=staging \
          -e DATABASE_URL=\$STAGING_DATABASE_URL \
          -e REDIS_URL=\$STAGING_REDIS_URL \
          --health-cmd='curl -f http://localhost:3000/health || exit 1' \
          --health-interval=30s \
          --health-timeout=10s \
          --health-retries=3 \
          $DOCKER_IMAGE
      "
    # Health check
    - sleep 30
    - |
      for i in {1..10}; do
        if curl -f https://staging.company.com/health; then
          echo "Staging deployment successful!"
          break
        fi
        echo "Waiting for staging to be ready... ($i/10)"
        sleep 10
      done
  dependencies:
    - build_image
  only:
    - develop
  when: manual

# Testes de Smoke no Staging
smoke_tests:
  stage: deploy
  image: node:18-alpine
  environment:
    name: staging
  script:
    - npm ci --only=dev
    - npm run test:smoke -- --baseUrl=https://staging.company.com
  dependencies:
    - deploy_staging
  only:
    - develop

# Deploy Produção
deploy_production:
  stage: deploy
  image: alpine:latest
  environment:
    name: production
    url: https://api.company.com
  before_script:
    - apk add --no-cache openssh-client
    - eval $(ssh-agent -s)
    - echo "$SSH_PRIVATE_KEY" | tr -d '\r' | ssh-add -
    - mkdir -p ~/.ssh
    - chmod 700 ~/.ssh
    - ssh-keyscan $PRODUCTION_SERVER >> ~/.ssh/known_hosts
  script:
    # Blue-Green Deployment
    - |
      ssh deploy@$PRODUCTION_SERVER "
        # Pull nova imagem
        docker pull $DOCKER_IMAGE
        
        # Identificar container ativo
        ACTIVE=\$(docker ps --filter 'name=api-blue' --format '{{.Names}}' | head -1)
        if [ \"\$ACTIVE\" = \"api-blue\" ]; then
          NEW_COLOR=\"green\"
          OLD_COLOR=\"blue\"
          NEW_PORT=\"3001\"
        else
          NEW_COLOR=\"blue\"
          OLD_COLOR=\"green\"
          NEW_PORT=\"3000\"
        fi
        
        echo \"Deploying to \$NEW_COLOR container\"
        
        # Iniciar novo container
        docker run -d --name api-\$NEW_COLOR \
          --restart unless-stopped \
          -p \$NEW_PORT:3000 \
          -e NODE_ENV=production \
          -e DATABASE_URL=\$PRODUCTION_DATABASE_URL \
          -e REDIS_URL=\$PRODUCTION_REDIS_URL \
          --health-cmd='curl -f http://localhost:3000/health || exit 1' \
          --health-interval=30s \
          --health-timeout=10s \
          --health-retries=3 \
          $DOCKER_IMAGE
        
        # Aguardar health check
        sleep 30
        until docker exec api-\$NEW_COLOR curl -f http://localhost:3000/health; do
          echo 'Waiting for new container to be healthy...'
          sleep 5
        done
        
        # Atualizar nginx para novo container
        sed -i \"s/server app:\$OLD_PORT/server app:\$NEW_PORT/g\" /etc/nginx/conf.d/api.conf
        nginx -s reload
        
        # Aguardar estabilização
        sleep 30
        
        # Remover container antigo
        docker stop api-\$OLD_COLOR
        docker rm api-\$OLD_COLOR
        
        echo \"Production deployment completed successfully!\"
      "
    # Verificação final
    - |
      for i in {1..10}; do
        if curl -f https://api.company.com/health; then
          echo "Production deployment verified!"
          exit 0
        fi
        echo "Waiting for production to be ready... ($i/10)"
        sleep 10
      done
      echo "Production deployment failed health check!"
      exit 1
  dependencies:
    - build_image
  only:
    - main
  when: manual
  allow_failure: false

# Rollback Production
rollback_production:
  stage: deploy
  image: alpine:latest
  environment:
    name: production
  script:
    - echo "Rolling back to previous version..."
    # Implementar lógica de rollback
  only:
    - main
  when: manual

# Cleanup
cleanup_old_images:
  stage: deploy
  image: docker:24-dind
  services:
    - docker:24-dind
  script:
    - echo $CI_REGISTRY_PASSWORD | docker login -u $CI_REGISTRY_USER --password-stdin $CI_REGISTRY
    # Manter apenas as últimas 10 imagens
    - |
      IMAGES=$(docker run --rm -e REGISTRY_AUTH_TOKEN=$CI_JOB_TOKEN \
        curlimages/curl:latest sh -c "
        curl -s -H 'Authorization: Bearer $CI_JOB_TOKEN' \
        '$CI_API_V4_URL/projects/$CI_PROJECT_ID/registry/repositories' | \
        jq -r '.[0].id'")
      
      docker run --rm -e REGISTRY_AUTH_TOKEN=$CI_JOB_TOKEN \
        curlimages/curl:latest sh -c "
        curl -s -H 'Authorization: Bearer $CI_JOB_TOKEN' \
        '$CI_API_V4_URL/projects/$CI_PROJECT_ID/registry/repositories/$IMAGES/tags' | \
        jq -r '.[10:] | .[].name' | \
        while read tag; do
          curl -X DELETE -H 'Authorization: Bearer $CI_JOB_TOKEN' \
          '$CI_API_V4_URL/projects/$CI_PROJECT_ID/registry/repositories/$IMAGES/tags/$tag'
        done"
  only:
    - schedules
